1.How to add new cell types in the model:
<plx_cellpopdata.py>
Insert cell info in lists like PMd case.
popnames = ['PMd', 'ER2', 'IF2', 'IL2', 'ER5', 'EB5', 'IF5', 'IL5', 'ER6', 'IF6', 'IL6']
popclasses =  [-1,    1,     2,     3,     1,     1,     2,     3,     1,     2,     3] # Izhikevich population type
popEorI =     [ 0,    0,     1,     1,     0,     0,     1,     1,     0,     1,     1] # Whether it's excitatory or inhibitory
popratios =  [numPMd,150,    25,    25,   167,    72,    40,    40,   192,    32,    32]
Prior cells will have lower gids. E.g., PMd.gid < ER2.gid <...<IL6.gid

Change cellproperties() according to the cell types:
cell info is returned to plx_model and the info is used for simulations.
For PMd type cells, the following is added, because the number of PMd cells are not changed as scale changes.
If cells increase in the cell types as scale increases, the following modification is not needed.
    indexPopName = checkIndexPopName('PMd', popnames) # checkIndexPopName returns PMd index in popnames
    if not indexPopName == -1:
        popnumbers[indexPopName] = numPMd # Number of PMds is fixed. # return back the number of PMd cells to numPMd.
"ncells" is a global value, and total number of cells in the model.

According to the cell types added, return statement in names2inds() and its call in plx_cellpopdata.py and plx_model.py should be updated.

def setconnprobs() needs connection probabilities for new cell types. Currently inserting PMds doesn't modify this function.

def setconnweights() needs new connection weight. For the PMds, connweights[PMd,ER2,AMPA]=10 was added.

<In plx_model.py>
Update "## set cell types." @Line 189
For PMd, "elif cellclasses[c]==-1: celltypes.append(pmdnsloc)" is added. pmdnsloc is defined in nsloc.py

Update "## set positions." @Line 202
Positions are changed. That is, if new cell types are added in the model, existing cells in the model will have different positions because of randomness change.
xlocs = modelsize*rand(ncells) # Create random x locations
ylocs = modelsize*rand(ncells) # Create random y locations
zlocs = verticalextent*rand(ncells) # Create random z locations
Add zlayer position update. For PMd, "elif cellnames[c][-1]=='d': zlocs[c]+=zlayerpositions[5]" is added. 'd' is in 'PMd'.

Update "## Actually create the cells." @Line 221
In this version(r2206 in SVN), all cells including new cells inserted are distributed evenly in a round-robin way by "for c in xrange(int(pc.id()), ncells, nhosts):."
"cellsperhost" indicates how many cells including new cell types inserted each worker created. Each worker might have different value of cellsperhost. 
For PMd, the following code snippet is executed for NULL->NetCon->PMd connection. NSLOC-based cell types will follow the code snippet, but inncl is only to feed PMds with external PMd spikes:
   if cellnames[gid] == 'PMd':
     cell = celltypes[gid](cellid = gid) # create an NSLOC
     inncl.append(h.NetCon(None, cell)) # This netcon will receive external PMd spikes
     innclDic[gid] = ninnclDic          # This dictionary will be used for NetCon search.
     ninnclDic += 1
   else:

Update ##calculate distance and probabilities. @Line 256
Connection probabilities among cells are calculated prior to making connections,  
However, PMds won't be post synaptic cells in the connections. So the following code snippet is only for PMds: 
   if cellnames[gid] == 'PMd':
      # There is no connection for cells -> PMds
      continue  
In order to make connections between the new cells added and others based on probabilities, def setconnprobs() in plx_cellpopdata.py should be modified accordingly. 
Connection between a ER2 and PMd is controlled explicitly by PMd[gid%numPMd]->ER2[gid]. So, if you want to control the connections for other cells, follow the code for PMds:

pmdStart = cpd.popGidStart[PMd] # get pmd's start gid by using cpd.popGidStart[cellname]
pmdEnd = cpd.popGidEnd[PMd]     # get PMd's end gid
for c in xrange(pmdStart, pmdEnd + 1):
   allrands[c] = 1 # set all PMd values in allrands to 1.
if cellnames[gid] == 'ER2':
  pMdId = (gid % numPMd)  # select PMd being connected to this ER2 cell.
  allconnprobs[pMdId] = 1 # to make this PMd connected to the ER2 cell
  allrands[pMdId] = 0     # to make this PMd connected to the ER2 cell
  distances[pMdId] = 300  # to make the NetCon delay for this connection 5ms

Update ## Add background inputs @Line 447
ER2 and PMd cells won't be fired by background spikes. The following avoid them not to be fired by background spikes:
gid = gidvec[c]
if isOriginal == 0:
    if cellnames[gid] == 'ER2' or cellnames[gid] == 'PMd': # 'ER2' won't be fired by background stimulations.
        continue

2.How to connect m1ms with Plexon?
# Connect m1ms with Plexon
- Copy m1ms/sim/Client to Windows machine having MATLAB and Plexon software.
- Open Client/plx_mat_interface.m on the Windows machine, and set up "remoteAddr" to the IP address m1ms runs on. In addition, set up "addapth" with the path for the library required for the Plexon software.
- Set up parameters in m1ms/sim/config.py accordingly.
  isOriginal|isCommunication|isQueueTest
  a. 1 | x | x - To run the original m1ms (Cliff's parallelized model). X means don't care
  b. 0 | 1 | 1 - To run m1ms w/o connection to Plexon, but with PMd spike files
  c. 0 | 1 | 0 - To run m1ms, getting spikes from Plexon through the communication program
  Note: for b and c, check if PMd spike file (spikePMd-6sec.txv) is in data/.

3. How to run m1ms?
For 2.a, 2.b:
$plx_runsim <# of workers>

For 2.c,
1. $plx_runsim <# of workers>
2. Run client in the Windows machine.
3. Run the Plexon softsever.

4. How to plot spikes?
Spikes are stored in m1ms/sim/m1ms-spk.txt.
$python quickplot.py or $python quickplot.py <filename> <scale> <duration for plot> <weight>
<filename>: default is m1ms-spk.txt
<scale>   : default is 10
<duration>: default is 6 (sec)
<weight>  : default is 0

